#!/bin/bash
#===============================================================================
#
# FILE: mapping
#
# USAGE: 
#
# DESCRIPTION: Compare given ENDF-6 chunk file to previouos library versions
#
# OPTIONS: see function ’usage’ below
# REQUIREMENTS: ---
# BUGS: ---
# NOTES: ---
# AUTHOR: Luca Fiorito, luca.fiorito@oecd.org
# COMPANY: OECD/NEA
# VERSION: ---
# CREATED: 26.01.2018
# REVISION: ---
#===============================================================================

CODE=$(basename "$0")                                           # Executable name
SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"   # Directory of this script
USAGE="Usage:

$CODE  CHUNKLIST  DIRLIST  [options]


POSITIONAL ARGUMENTS
--------------------

CHUNKLIST                   List 

DIRLIST                     List



KEYWORD ARGUMENTS
-----------------

-h|--help                   Print the help text.

-z|--zip                    Perform comparison on zipped files using zcmp.

--xml-output                Produce xml output.
"



#######################################################################
#######################################################################
#                                                                     #
#                    PARSE COMMAND LINE ARGUMENTS                     #
#                                                                     #
#######################################################################
#######################################################################
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    -h|--help) # print USAGE and exit with status 0
    echo -e "$USAGE"
    exit 0
    ;;
    -z|--zip)
    ZIP="--zip"
    shift # past argument
    ;;
    --xml-output)
    XML="$2"
    shift # past argument
    shift # past value
    ;;
    *)    # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift # past argument
    ;;
esac
done



#######################################################################
#######################################################################
#                                                                     #
#                          PROCESS INPUTS                             #
#                                                                     #
#######################################################################
#######################################################################
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get CHUNKLIST and DIRLIST from positional arguments.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
msg="ERROR: missing positional arguments \"CHUNKLIST\"/\"DIRLIST\".\n$USAGE"
[[ ${#POSITIONAL[@]} -lt 2 ]] && { >&2 echo -e "$msg"; exit 1; }
CHUNKLIST="${POSITIONAL[0]}"
DIRLIST="${POSITIONAL[1]}"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get ENDF-6 chunks from file CHUNKLIST.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if [[ -d "$CHUNKLIST" ]]
then
   CHUNKLIST=($(find $(realpath "$CHUNKLIST") -maxdepth 1 -type f -o -type l))
elif [[ -s "$CHUNKLIST" ]]
then
   CHUNKLIST=($(cat "$CHUNKLIST"))
else
   >&2 echo -e "ERROR: no file or directory called '$CHUNKLIST'"; exit 1
fi
[[ ${#CHUNKLIST[@]} -eq 0 ]] && {>&2 echo -e "ERROR: no ENDF-6 chunk file was given.";exit 1;}
printf '%d chunk files given\n' "${#CHUNKLIST[@]}"
for CHUNK in ${CHUNKLIST[@]}
do
   [[ -s "$CHUNK" ]] || { >&2 echo -e "ERROR: empty or non-existing ENDF-6 chunk file '$CHUNK'"; exit 1; }
done
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get directories (DIRS) and associated keywords (KEYS).
# Skip lines starting with # symbol.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[[ -s "$DIRLIST" ]] || { >&2 echo -e "ERROR: no file called '$DIRLIST'"; exit 1; }
DIRS=($( awk '/^[^\#]/ {print $1}' $DIRLIST ))
KEYS=($( awk '/^[^\#]/ {print $2}' $DIRLIST ))
NDIRS=${#DIRS[@]}
for DIR in ${DIRS[@]}
do
   [[ -d "$DIR" ]] || { >&2 echo -e "ERROR: no directory called '$DIR'"; exit 1; }
done
[[ $NDIRS -ne ${#KEYS[@]} ]] && { >&2 echo -e "ERROR: number of directory differs from number of keywords."; exit 1; }



#######################################################################
#######################################################################
#                                                                     #
#                    DO THE MAPPING                                   #
#                                                                     #
#######################################################################
#######################################################################
[[ -z $XML ]] || printf "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" > "$XML"
[[ -z $XML ]] || printf "<evals>\n" >> "$XML"
for CHUNK in ${CHUNKLIST[@]}
do
   NAME="$(basename $CHUNK)"
   MAT="$(echo $NAME | cut -c1-4 | sed 's/^0*//')"
   MF="$(echo $NAME | cut -c5-6 | sed 's/^0*//')"
   MT="$(echo $NAME | cut -c7-9 | sed 's/^0*//')"
   for i in $(seq 0 $(($NDIRS-1)))
   do
      OLD="${DIRS[$i]}/$(basename $CHUNK)"
      if [[ -s $OLD ]]
      then
         [[ -z $ZIP ]] && CMD="cmp" || CMD="zcmp"
         $CMD --silent $OLD $CHUNK && { ORIGIN=${KEYS[$i]}; break; }
      fi
   done
   printf "%s  ORIGIN  %s\n" "$CHUNK" "${ORIGIN:-NEW}"
   [[ -z $XML ]] || printf "  <section>\n" >> "$XML"
   [[ -z $XML ]] || printf "    <mat>%s</mat>\n" $MAT >> "$XML"
   [[ -z $XML ]] || printf "    <mf>%s</mf>\n" $MF >> "$XML"
   [[ -z $XML ]] || printf "    <mt>%s</mt>\n" $MT >> "$XML"
   [[ -z $XML ]] || printf "    <origin>%s</origin>\n" $ORIGIN >> "$XML"
   [[ -z $XML ]] || printf "  </section>\n" >> "$XML"
   unset ORIGIN
done
[[ -z $XML ]] || printf "</evals>\n" >> "$XML"
