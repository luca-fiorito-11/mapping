#!/bin/bash
#===============================================================================
#
# FILE: splitting
#
# USAGE:
#
# DESCRIPTION: Split ENDF-6 file into chunks.
#
# OPTIONS: see function ’usage’ below
# REQUIREMENTS: ---
# BUGS: ---
# NOTES: ---
# AUTHOR: Luca Fiorito, luca.fiorito@oecd.org
# COMPANY: OECD/NEA
# VERSION: ---
# CREATED: 26.01.2018
# REVISION: ---
#===============================================================================

CODE=$(basename "$0")                                           # Executable name
SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"   # Directory of this script
USAGE="Usage:

$CODE  FILE  [options]


POSITIONAL ARGUMENTS
--------------------

FILE                        input ENDF-6 file.


KEYWORD ARGUMENTS
-----------------

-h|--help                   Print the help text.

-t|--target-directory       

-z|--zip                    
"



#######################################################################
#######################################################################
#                                                                     #
#                    PARSE COMMAND LINE ARGUMENTS                     #
#                                                                     #
#######################################################################
#######################################################################
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
-h|--help) # print USAGE and exit with status 0
echo -e "$USAGE"
exit 0
;;
-t|--target-directory)
TWD="$2"
shift # past argument
shift # past value
;;
-z|--zip)
ZIP="--zip"
shift # past argument
;;
--tmp-directory)
TMP="--tmp-directory"
shift # past argument
;;
*)    # unknown option
POSITIONAL+=("$1") # save it in an array for later
shift # past argument
;;
esac
done



#######################################################################
#######################################################################
#                                                                     #
#                          PROCESS INPUTS                             #
#                                                                     #
#######################################################################
#######################################################################
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get FILE from positional arguments.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
msg="ERROR: missing positional argument \"FILE\".\n$USAGE"
[[ ${#POSITIONAL[@]} -lt 1 ]] && { >&2 echo -e "$msg"; exit 1; }
FILE="$( realpath ${POSITIONAL[0]})"
NAME="$( basename $FILE)"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set target working directory
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TWD="${TWD:-$(pwd)}"
[[ -d "$TWD" ]] ||  { >&2 echo -e "ERROR: no existing directory called '$TWD'"; exit 1; }
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set target working directory
# Standardization and csplit is done in temporary folder
# to prevent from overwriting files with same name when
# script is executed in parallel.
# 
# Random number is added to the temporary directory (in 
# case two files with the same name are processed).
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TMP="${TWD}/.${NAME}_${RANDOM}.tmp"
mkdir -p "$TMP"



#######################################################################
#######################################################################
#                                                                     #
#                        STANDARDIZE                                  #
#                                                                     #
#######################################################################
#######################################################################
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ENDF2C="${SCRIPTDIR}/data/codes/endf2c"
{
cd $TMP &&
ln -sf "$FILE" ENDFB.IN
"$ENDF2C" >/dev/null 2>&1
EXIT_STATUS=$?
[[ "$EXIT_STATUS" -ne "0" ]] && { >&2 echo -e "ERROR: File '$FILE' not in ENDF-6 format"; exit 1; }
}


#######################################################################
#######################################################################
#                                                                     #
#                        DO THE SPLITTING                             #
#                                                                     #
#######################################################################
#######################################################################
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
REGEX="^.\{74\}0.\{5\}$"
{
cd "$TMP" &&
csplit ENDFB.OUT /"${REGEX}"/ {*} --suppress-matched -z --prefix="${NAME}." --quiet
for file in $(find . -maxdepth 1 -type f -name "${NAME}.*")
do
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # The first line should always contain MAT/MF/MT because 
   # endf2c is run before
   # In theory sed should never be called.
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   CHUNK="$(head -1 "$file" | cut -c67-75 | tr ' ' 0)"
   [[ -z $CHUNK || ${#CHUNK} -ne 9 ]] && CHUNK="$(sed -n '2,2 p' "$file" | cut -c67-75 | tr ' ' 0)"
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # Keep only the first 66 characters of each line.
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   awk '{print substr($0,1,66)}' "$file" > "$TWD/$CHUNK"
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # Zip if requested.
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   [[ -z $ZIP ]] || gzip "$CHUNK"
done
#rm -rf ENDFB.IN ENDFB.OUT ENDF2C.LST "${NAME}."*
}
rm -rf "$TMP"
